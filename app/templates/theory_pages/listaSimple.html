{% extends '././layout.html' %}

{% block title %}Theory: Simple Linked List{% endblock %}

{% block body %}

<!-- IMPORT PRISM LIBRARY FOR THE HIGHLIGHT -->
<script src="{{url_for('static', filename='js/prism.js')}}"></script>
<link rel="stylesheet" href="{{url_for('static', filename='css/prism.css')}}">
<!-- -->

<div class="container">

    <h1>LISTA SIMPLEMENTE ENLAZADA: </h1><hr><br>

    <h2>DEFINICIÓN: </h2>

    <p  class="lead text-justify">Una lista simplemente enlazada consiste en una sucesión de nodos en la que cada uno apunta únicamente al siguiente en la lista,<b> a excepción del último nodo en la lista, que simplemente apuntará a null.</b> Con la siguiente imágen se puede apreciar de mejor manera la definición: </p>

    <br>
    <img src="{{url_for('static', filename='img/theory_simple_linked_list.jpg')}}" alt="Lista simplemente enlazada" class="img-fluid mx-auto d-block"><br>

    <p class="lead text-justify">Si quiere descargar la implementación de la lista simplemente enlzadada en TypeScript, haga click en el siguiente botón: </p>
    <a href="{{url_for('static', filename='downloads/SimpleLinkedList.ts')}}" download="SimpleLinkedList"><button class="btn btn-primary mb-3" style="color: white;">DESCARGAR .ts</button></a>

    <!-- ---------------------- -->
    <!--MÉTODOS DEL NODO-->
    <!-- ---------------------- -->
    
    <h2>MÉTODOS BÁSICOS DEL NODO: </h2>

    <p class="lead text-justify">Como bien se mencionó anteriormente, la lista simplemente enlazada está conformada por nodos, y estos nodos tienen sus propios atributos, los más importantes son: </p>

    <ol>
        <!--MÉTODO 1-->
        <li class="lead text-justify">Método para saber si el nodo contiene un objeto: 
        <pre><code class="language-typescript">
//Método para saber si un nodo almacena un objeto
isEquals(object:any):Boolean{
    //Es importante verificar también el tipo del dato
    if(this.data === object){   
        return true; 
    }else{
        return false; 
    }
}
        </code></pre>
        </li>

        <!--MÉTODO 2-->
        <li class="lead text-justify">Método para imprimir todos los nodos, "en cadena": 
        <pre><code class="language-typescript">
toString():void{
    if(this.next_node != null){
        console.log("ListNode: " + " Data: " + this.data + " NextNode -> ");
        this.next_node.toString(); 
    }else{
        console.log("ListNode: " + " Data: " + this.data + " NextNode: NULL");
    }
}            
        </code></pre>
        </li>

    </ol>

    <p class="lead text-justify">El anterior método es muy útil, ya que más adelante nos permitirá imprimir toda la lista enlazada llamando al método toString() de la cabeza de la lista. <br><br>

    Además de los anteriores métodos, claramente los nodos deben tener su método constructor, sus getters y sus setters.</p><br>

    <!-- ---------------------- -->
    <!--MÉTODOS DE LA LISTA-->
    <!-- ---------------------- -->
    <h2>MÉTODOS BÁSICOS DE LA LISTA: </h2><br>
    <p class="lead text-justify">Así como los nodos de la lista tenían sus propios métodos, la lista también tiene los suyos: </p>

    <ol>

        <li class="lead text-justify">Método para insertar un nuevo dato después de la cola de la lista: 

        <!--MÉTODO 1-->
        <pre><code class="language-typescript">
insert(object:any){

    //Se crea el nodo que contrendrá el nuevo objeto
    let new_node:list_node = new list_node(object);
    
    if(this.head == null){
        //Si la cabeza de la lista es nula, significa que no hay objetos en la lista
        this.head! = new_node;      //Se añade el objeto en la cabeza
        this.tail! = this.head!;    //La cola será la misma cabeza, ya que no hay más nodos
    }else{
        this.tail!.set_next_node = new_node;    //Si ya hay datos, se añade el siguiente nodo después de la cola
        this.tail = new_node;   //La nueva cola será el nuevo nodo
    }

    this.size++;                        //Aumentamos el size de la lista tras hacer el insert

}
        </code></pre>
        </li>

        <!--MÉTODO 2-->
        <li class="lead text-justify">Método para insertar un objeto en la cabeza de la lista:
        <pre><code class="language-typescript">
insertAtHead(object:any){

    if(this.isEmpty() == true){

        //Si la lista está vacía, simplemente se llama al método insert()
        this.insert(object); 

    }else{

        let new_head = new list_node(object); 
        new_head.set_next_node = this.head!;    //El siguiente nodo al nuevo nodo será la anterior cabeza

        this.head = new_head;   //La nueva cabeza será el nuevo nodo

    }

            }
        </code></pre>
        </li>

        <!--MÉTODO 3-->
        <li class="lead text-justify">Método para saber si la lista contiene un dato: 
            <pre><code class="language-typescript">
search(object:any):boolean{

    if(this.head != null){

        let current_node:list_node|null = this.head!;

        for(let i=0; i< this.size; i++){

            if(current_node!.get_data === object){

                return true; 

            }

            current_node = current_node!.get_next_node; 

        }

    }else{

        return false;   //Si la lista está vacía, retorna falso

    }

    return false;       //Si no estaba vacía, pero no se encontró el objeto, retorna falso

}    
            </code></pre>
        </li>

        <!--MÉTODO 4-->
        <li class="lead text-justify">Método para remover un objeto de la lista: 
            <pre><code class="language-typescript">
remove(object:any):boolean{

    //Primero se verifica si la lista contiene el objeto
    if(this.search(object) == false){
        return false;
    }else{

        //Si la lista sí contiene el objeto, se revisa primero si lo contiene la cabeza
        if(this.head!.isEquals(object)){

            this.head = this.get_head!.get_next_node;   //La cabeza será el siguiente nodo a la anterior cabeza

        }else{

            //Si el objeto no lo contiene la cabeza, es necesario iterar en la lista hasta encontrar el nodo que lo contenga
            let current_node:list_node = this.head!; 

            for(let i=1; i< this.size; i++){

                if(current_node.get_next_node!.isEquals(object)){

                    //Si el nodo que contiene el objeto es el siguiente nodo a "current_node", se deja de iterar
                    break; 

                }

                //Si no se ha encontrado, se sigue iterando
                current_node = current_node!.get_next_node!; 

            }

            //Cuando se termine de iterar, se hace el cambio 
            current_node.set_next_node = current_node.get_next_node!.get_next_node; 

        }

        return true; 

    }


}   
            </code></pre>
        </li>

        <!--MÉTODO 5-->
        <li class="lead text-justify">Método para insertar un objeto en un índice específico de la lista: 
            <pre><code class="language-typescript">
insertAt(object:any, index:number){

    if(index == this.size){

        //Si se quiere insertar al final de la lista, se llama al método insert
        this.insert(object); 

    }else if(index == 0){

        //Si se quiere insertar en el índice 0 (la cabeza), se llama al método insertAtHead()
        this.insertAtHead(object); 

    }else{

        //Si no se quiere insertar ni en la cabeza ni en la cola, se itera hasta encontrar la posición
        let current_node:list_node = this.head!; 

        for(let i=1; i< index; i++){

            current_node = current_node.get_next_node!; 

        }

        //Cuando se encuentre la posición, se hacen los cambios
        let new_node:list_node = new list_node(object); 
        new_node.set_next_node = current_node.get_next_node; 
        current_node.set_next_node = new_node; 

    }

}   
            </code></pre>
        </li>
    </ol>
    
    <p class="lead text-justify">Cabe resaltar que los anteriores son únicamente los métodos esenciales de la lista simplemente enlazada, ya que la lista puede tener más métodos útiles como: </p>

    <ul>
        <li class="lead text-justify"><b>Sort():</b> Método que permitiría ordenar la lista, ya sea en orden ascendente o descendente. </li><br>
        <li class="lead text-justify"><b>ToArray():</b> Método para convertir la lista simplemente enlazada a un array. </li><br>
        <li class="lead text-justify"><b>SearchNode(object):</b> Método que al igual que search, permite buscar un objeto en la lista, pero debería retornar el nodo que contiene el objeto. Este método sería útil en caso de que, por ejemplo, se quiera modificar/eliminar ese nodo. </li><br>
        <li class="lead text-justify"><b>Sublist(index_start, index_end):</b> Este método permitiría generar una sublista simplemente enlazada, desde el índice de inicio hasta el índice de final. </li>
    </ul>

</div>

{% endblock %}